package yaml

import (
	"bytes"
	"fmt"
	"io"
	"reflect"
	"strings"

	"github.com/goccy/go-yaml"
	"github.com/pkg/errors"
)

const generatedNotice = "# Code generated by %s; DO NOT EDIT.\n"

// Encode encodes any interface with the given options.
// The output is already formatted.
func Encode(v interface{}, opts ...EncodeOption) ([]byte, error) {
	b := &bytes.Buffer{}
	if err := newEncoder(b).encode(v, opts...); err != nil {
		return nil, err
	}

	return b.Bytes(), nil
}

type encoder struct {
	w io.Writer

	notice          string
	useMapstructure bool
	useYAMLV3       bool
}

func newEncoder(w io.Writer) *encoder { return &encoder{w: w} }

func (e *encoder) encode(v interface{}, opts ...EncodeOption) error {
	for _, opt := range opts {
		opt(e)
	}

	if e.notice != "" {
		if _, err := e.w.Write([]byte(e.notice)); err != nil {
			return errors.Wrap(err, "writing notice")
		}
	}

	if e.useYAMLV3 {
		return e.encodeV3(v)
	}

	if e.useMapstructure {
		v = e.transformToMap(v)
	}

	n, err := yaml.ValueToNode(v,
		yaml.UseLiteralStyleIfMultiline(true),
		yaml.IndentSequence(true),
		yaml.UseSingleQuote(true))
	if err != nil {
		return errors.Wrap(err, "transforming value to node")
	}

	return errors.Wrap(yaml.NewEncoder(e.w).Encode(n), "encoding node")
}

func (e *encoder) encodeV3(v interface{}) error {
	res, err := Marshal(v)
	if err != nil {
		return err
	}

	_, err = e.w.Write(res)
	return err
}

func (e *encoder) transformToMap(v interface{}) interface{} {
	rv := reflect.Indirect(reflect.ValueOf(v))

	if rv.Kind() != reflect.Struct {
		return v
	}

	tp := rv.Type()
	m := map[string]interface{}{}

	for i, l := 0, tp.NumField(); i < l; i++ {
		sf := tp.Field(i)
		if !sf.IsExported() {
			continue
		}

		fv := e.transformToMap(rv.Field(i).Interface())

		if isEmptyValue(reflect.ValueOf(fv)) {
			continue
		}

		m[fieldName(sf)] = fv
	}

	return m
}

func fieldName(sf reflect.StructField) string {
	if s := sf.Tag.Get("mapstructure"); s != "" {
		return s
	}

	if s := sf.Tag.Get("yaml"); s != "" {
		return strings.Split(s, ",")[0]
	}

	return strings.ToLower(sf.Name)
}

// taken from encoding/json/encode.go.
func isEmptyValue(v reflect.Value) bool {
	switch v.Kind() {
	case reflect.Array, reflect.Map, reflect.Slice, reflect.String:
		return v.Len() == 0
	case reflect.Bool:
		return !v.Bool()
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return v.Int() == 0
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		return v.Uint() == 0
	case reflect.Float32, reflect.Float64:
		return v.Float() == 0
	case reflect.Interface, reflect.Ptr:
		return v.IsNil()
	default:
		return false
	}
}

// EncodeOption is an option to encode an interface in a certain way.
type EncodeOption func(e *encoder)

// AddDoNotEditNotice adds a notice on top of the yaml that it should not be edited.
func AddDoNotEditNotice(cmd string) EncodeOption {
	return func(e *encoder) {
		e.notice = fmt.Sprintf(generatedNotice, cmd)
	}
}

// RemoveNotice removes any setting specifying a notice to be added.
var RemoveNotice EncodeOption = func(e *encoder) {
	e.notice = ""
}

// UseMapstructure encodes the yaml file in such a way that it can be decoded by github.com/mitchellh/mapstructure.
var UseMapstructure EncodeOption = func(e *encoder) {
	e.useMapstructure = true
}

// UseYAMLV3 encodes the yaml using "gopkg.in/yaml.v3".
var UseYAMLV3 EncodeOption = func(e *encoder) {
	e.useYAMLV3 = true
}
