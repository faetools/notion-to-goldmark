// Package notion provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/faetools/devtool version (devel) DO NOT EDIT.
package notion

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/faetools/client"
)

// operation paths

const (
	opPathDeleteBlockFormat    = "./v1/blocks/%s"
	opPathGetBlockFormat       = "./v1/blocks/%s"
	opPathUpdateablockFormat   = "./v1/blocks/%s"
	opPathGetBlocksFormat      = "./v1/blocks/%s/children"
	opPathAppendBlocksFormat   = "./v1/blocks/%s/children"
	opPathGetDatabaseFormat    = "./v1/databases/%s"
	opPathUpdateDatabaseFormat = "./v1/databases/%s"
	opPathQueryDatabaseFormat  = "./v1/databases/%s/query"
	opPathDeletePageFormat     = "./v1/pages/%s"
	opPathGetPageFormat        = "./v1/pages/%s"
	opPathUpdatePageFormat     = "./v1/pages/%s"
	opPathGetUserFormat        = "./v1/users/%s"
)

var (
	opPathCreateDatabase = client.MustParseURL("./v1/databases/")
	opPathCreatePage     = client.MustParseURL("./v1/pages/")
	opPathSearch         = client.MustParseURL("./v1/search")
	opPathListUsers      = client.MustParseURL("./v1/users")
	opPathGetMe          = client.MustParseURL("./v1/users/me")
)

// ClientInterface interface specification for the client.
type ClientInterface interface {
	// DeleteBlock request
	DeleteBlock(ctx context.Context, id Id, reqEditors ...client.RequestEditorFn) (*DeleteBlockResponse, error)

	// GetBlock request
	GetBlock(ctx context.Context, id Id, reqEditors ...client.RequestEditorFn) (*GetBlockResponse, error)

	// Updateablock request with any body
	UpdateablockWithBody(ctx context.Context, id Id, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateablockResponse, error)

	// GetBlocks request
	GetBlocks(ctx context.Context, id Id, params *GetBlocksParams, reqEditors ...client.RequestEditorFn) (*GetBlocksResponse, error)

	// AppendBlocks request with any body
	AppendBlocksWithBody(ctx context.Context, id Id, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*AppendBlocksResponse, error)

	AppendBlocks(ctx context.Context, id Id, body AppendBlocksJSONRequestBody, reqEditors ...client.RequestEditorFn) (*AppendBlocksResponse, error)

	// CreateDatabase request with any body
	CreateDatabaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateDatabaseResponse, error)

	CreateDatabase(ctx context.Context, body CreateDatabaseJSONRequestBody, reqEditors ...client.RequestEditorFn) (*CreateDatabaseResponse, error)

	// GetDatabase request
	GetDatabase(ctx context.Context, id Id, reqEditors ...client.RequestEditorFn) (*GetDatabaseResponse, error)

	// UpdateDatabase request with any body
	UpdateDatabaseWithBody(ctx context.Context, id Id, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateDatabaseResponse, error)

	UpdateDatabase(ctx context.Context, id Id, body UpdateDatabaseJSONRequestBody, reqEditors ...client.RequestEditorFn) (*UpdateDatabaseResponse, error)

	// QueryDatabase request with any body
	QueryDatabaseWithBody(ctx context.Context, id Id, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*QueryDatabaseResponse, error)

	QueryDatabase(ctx context.Context, id Id, body QueryDatabaseJSONRequestBody, reqEditors ...client.RequestEditorFn) (*QueryDatabaseResponse, error)

	// CreatePage request with any body
	CreatePageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreatePageResponse, error)

	CreatePage(ctx context.Context, body CreatePageJSONRequestBody, reqEditors ...client.RequestEditorFn) (*CreatePageResponse, error)

	// DeletePage request
	DeletePage(ctx context.Context, id Id, reqEditors ...client.RequestEditorFn) (*DeletePageResponse, error)

	// GetPage request
	GetPage(ctx context.Context, id Id, reqEditors ...client.RequestEditorFn) (*GetPageResponse, error)

	// UpdatePage request with any body
	UpdatePageWithBody(ctx context.Context, id Id, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdatePageResponse, error)

	UpdatePage(ctx context.Context, id Id, body UpdatePageJSONRequestBody, reqEditors ...client.RequestEditorFn) (*UpdatePageResponse, error)

	// Search request with any body
	SearchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*SearchResponse, error)

	Search(ctx context.Context, body SearchJSONRequestBody, reqEditors ...client.RequestEditorFn) (*SearchResponse, error)

	// ListUsers request
	ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...client.RequestEditorFn) (*ListUsersResponse, error)

	// GetMe request
	GetMe(ctx context.Context, reqEditors ...client.RequestEditorFn) (*GetMeResponse, error)

	// GetUser request
	GetUser(ctx context.Context, id Id, reqEditors ...client.RequestEditorFn) (*GetUserResponse, error)
}

// Client definition

// compile time assert that it fulfils the interface
var _ ClientInterface = (*Client)(nil)

// Client conforms to the OpenAPI3 specification for this service.
type Client client.Client

// NewClient creates a new Client with reasonable defaults.
func NewClient(opts ...client.Option) (*Client, error) {
	c, err := client.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	if c.BaseURL == nil {
		if err := client.WithBaseURL(DefaultServer)(c); err != nil {
			return nil, err
		}
	}

	return (*Client)(c), nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []client.RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	return nil
}

// DeleteBlock: DELETE /v1/blocks/{id}

type DeleteBlockResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Block
	JSON400      *Error
	JSON404      *Error
	JSON429      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteBlockResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBlockResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteBlockRequest generates requests for DeleteBlock
func newDeleteBlockRequest(baseURL *url.URL, id Id) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("id", id)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteBlockFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteBlock returns a parsed response.
// DELETE /v1/blocks/{id}
func (c *Client) DeleteBlock(ctx context.Context, id Id, reqEditors ...client.RequestEditorFn) (*DeleteBlockResponse, error) {
	req, err := newDeleteBlockRequest(c.BaseURL, id)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteBlockResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Block
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// GetBlock: GET /v1/blocks/{id}

type GetBlockResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Block
	JSON400      *Error
	JSON404      *Error
	JSON429      *Error
}

// Status returns HTTPResponse.Status
func (r GetBlockResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newGetBlockRequest generates requests for GetBlock
func newGetBlockRequest(baseURL *url.URL, id Id) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("id", id)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathGetBlockFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// GetBlock returns a parsed response.
// GET /v1/blocks/{id}
func (c *Client) GetBlock(ctx context.Context, id Id, reqEditors ...client.RequestEditorFn) (*GetBlockResponse, error) {
	req, err := newGetBlockRequest(c.BaseURL, id)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &GetBlockResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Block
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// Updateablock: PATCH /v1/blocks/{id}

type UpdateablockResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Block
	JSON400      *Error
	JSON404      *Error
	JSON429      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateablockResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateablockResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateablockRequestWithBody generates requests for Updateablock with any type of body
func newUpdateablockRequestWithBody(baseURL *url.URL, id Id, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("id", id)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateablockFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPatch, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateablockWithBody returns a parsed response.
// PATCH /v1/blocks/{id}
func (c *Client) UpdateablockWithBody(ctx context.Context, id Id, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateablockResponse, error) {
	req, err := newUpdateablockRequestWithBody(c.BaseURL, id, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateablockResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Block
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// GetBlocks: GET /v1/blocks/{id}/children

type GetBlocksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlocksList
	JSON400      *Error
	JSON404      *Error
	JSON429      *Error
}

// Status returns HTTPResponse.Status
func (r GetBlocksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlocksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newGetBlocksRequest generates requests for GetBlocks
func newGetBlocksRequest(baseURL *url.URL, id Id, params *GetBlocksParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("id", id)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathGetBlocksFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if err := client.AddQueryParam(q, "page_size", params.PageSize); err != nil {
		return nil, err
	}

	if params.StartCursor != nil {
		if err := client.AddQueryParam(q, "start_cursor", *params.StartCursor); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// GetBlocks returns a parsed response.
// GET /v1/blocks/{id}/children
func (c *Client) GetBlocks(ctx context.Context, id Id, params *GetBlocksParams, reqEditors ...client.RequestEditorFn) (*GetBlocksResponse, error) {
	req, err := newGetBlocksRequest(c.BaseURL, id, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &GetBlocksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlocksList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// AppendBlocks: PATCH /v1/blocks/{id}/children

type AppendBlocksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlocksList
	JSON400      *Error
	JSON404      *Error
	JSON429      *Error
}

// Status returns HTTPResponse.Status
func (r AppendBlocksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppendBlocksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newAppendBlocksRequestWithBody generates requests for AppendBlocks with any type of body
func newAppendBlocksRequestWithBody(baseURL *url.URL, id Id, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("id", id)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathAppendBlocksFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPatch, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// AppendBlocksWithBody returns a parsed response.
// PATCH /v1/blocks/{id}/children
func (c *Client) AppendBlocksWithBody(ctx context.Context, id Id, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*AppendBlocksResponse, error) {
	rsp, err := c.doAppendBlocksWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}

	return parseAppendBlocksResponse(rsp)
}

func (c *Client) doAppendBlocksWithBody(ctx context.Context, id Id, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*http.Response, error) {
	req, err := newAppendBlocksRequestWithBody(c.BaseURL, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	return c.Client.Do(req)
}

func (c *Client) AppendBlocks(ctx context.Context, id Id, body AppendBlocksJSONRequestBody, reqEditors ...client.RequestEditorFn) (*AppendBlocksResponse, error) {
	rsp, err := c.doAppendBlocks(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}

	return parseAppendBlocksResponse(rsp)
}

// newAppendBlocksRequest calls the generic AppendBlocks builder with application/json body.
func newAppendBlocksRequest(baseURL *url.URL, id Id, body AppendBlocksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return newAppendBlocksRequestWithBody(baseURL, id, client.MIMEApplicationJSON, bodyReader)
}

func (c *Client) doAppendBlocks(ctx context.Context, id Id, body AppendBlocksJSONRequestBody, reqEditors ...client.RequestEditorFn) (*http.Response, error) {
	req, err := newAppendBlocksRequest(c.BaseURL, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	return c.Client.Do(req)
}

// parseAppendBlocksResponse parses an HTTP response from a AppendBlocks call.
func parseAppendBlocksResponse(rsp *http.Response) (*AppendBlocksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &AppendBlocksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlocksList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// CreateDatabase: POST /v1/databases/

type CreateDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Database
	JSON400      *Error
	JSON404      *Error
	JSON429      *Error
}

// Status returns HTTPResponse.Status
func (r CreateDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateDatabaseRequestWithBody generates requests for CreateDatabase with any type of body
func newCreateDatabaseRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateDatabase)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateDatabaseWithBody returns a parsed response.
// POST /v1/databases/
func (c *Client) CreateDatabaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateDatabaseResponse, error) {
	rsp, err := c.doCreateDatabaseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}

	return parseCreateDatabaseResponse(rsp)
}

func (c *Client) doCreateDatabaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*http.Response, error) {
	req, err := newCreateDatabaseRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	return c.Client.Do(req)
}

func (c *Client) CreateDatabase(ctx context.Context, body CreateDatabaseJSONRequestBody, reqEditors ...client.RequestEditorFn) (*CreateDatabaseResponse, error) {
	rsp, err := c.doCreateDatabase(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}

	return parseCreateDatabaseResponse(rsp)
}

// newCreateDatabaseRequest calls the generic CreateDatabase builder with application/json body.
func newCreateDatabaseRequest(baseURL *url.URL, body CreateDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return newCreateDatabaseRequestWithBody(baseURL, client.MIMEApplicationJSON, bodyReader)
}

func (c *Client) doCreateDatabase(ctx context.Context, body CreateDatabaseJSONRequestBody, reqEditors ...client.RequestEditorFn) (*http.Response, error) {
	req, err := newCreateDatabaseRequest(c.BaseURL, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	return c.Client.Do(req)
}

// parseCreateDatabaseResponse parses an HTTP response from a CreateDatabase call.
func parseCreateDatabaseResponse(rsp *http.Response) (*CreateDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Database
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// GetDatabase: GET /v1/databases/{id}

type GetDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Database
	JSON400      *Error
	JSON404      *Error
	JSON429      *Error
}

// Status returns HTTPResponse.Status
func (r GetDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newGetDatabaseRequest generates requests for GetDatabase
func newGetDatabaseRequest(baseURL *url.URL, id Id) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("id", id)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathGetDatabaseFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// GetDatabase returns a parsed response.
// GET /v1/databases/{id}
func (c *Client) GetDatabase(ctx context.Context, id Id, reqEditors ...client.RequestEditorFn) (*GetDatabaseResponse, error) {
	req, err := newGetDatabaseRequest(c.BaseURL, id)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &GetDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Database
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// UpdateDatabase: PATCH /v1/databases/{id}

type UpdateDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Database
	JSON400      *Error
	JSON404      *Error
	JSON429      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateDatabaseRequestWithBody generates requests for UpdateDatabase with any type of body
func newUpdateDatabaseRequestWithBody(baseURL *url.URL, id Id, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("id", id)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateDatabaseFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPatch, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateDatabaseWithBody returns a parsed response.
// PATCH /v1/databases/{id}
func (c *Client) UpdateDatabaseWithBody(ctx context.Context, id Id, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateDatabaseResponse, error) {
	rsp, err := c.doUpdateDatabaseWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}

	return parseUpdateDatabaseResponse(rsp)
}

func (c *Client) doUpdateDatabaseWithBody(ctx context.Context, id Id, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*http.Response, error) {
	req, err := newUpdateDatabaseRequestWithBody(c.BaseURL, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	return c.Client.Do(req)
}

func (c *Client) UpdateDatabase(ctx context.Context, id Id, body UpdateDatabaseJSONRequestBody, reqEditors ...client.RequestEditorFn) (*UpdateDatabaseResponse, error) {
	rsp, err := c.doUpdateDatabase(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}

	return parseUpdateDatabaseResponse(rsp)
}

// newUpdateDatabaseRequest calls the generic UpdateDatabase builder with application/json body.
func newUpdateDatabaseRequest(baseURL *url.URL, id Id, body UpdateDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return newUpdateDatabaseRequestWithBody(baseURL, id, client.MIMEApplicationJSON, bodyReader)
}

func (c *Client) doUpdateDatabase(ctx context.Context, id Id, body UpdateDatabaseJSONRequestBody, reqEditors ...client.RequestEditorFn) (*http.Response, error) {
	req, err := newUpdateDatabaseRequest(c.BaseURL, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	return c.Client.Do(req)
}

// parseUpdateDatabaseResponse parses an HTTP response from a UpdateDatabase call.
func parseUpdateDatabaseResponse(rsp *http.Response) (*UpdateDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Database
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// QueryDatabase: POST /v1/databases/{id}/query

type QueryDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagesList
	JSON400      *Error
	JSON404      *Error
	JSON429      *Error
}

// Status returns HTTPResponse.Status
func (r QueryDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newQueryDatabaseRequestWithBody generates requests for QueryDatabase with any type of body
func newQueryDatabaseRequestWithBody(baseURL *url.URL, id Id, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("id", id)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathQueryDatabaseFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// QueryDatabaseWithBody returns a parsed response.
// POST /v1/databases/{id}/query
func (c *Client) QueryDatabaseWithBody(ctx context.Context, id Id, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*QueryDatabaseResponse, error) {
	rsp, err := c.doQueryDatabaseWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}

	return parseQueryDatabaseResponse(rsp)
}

func (c *Client) doQueryDatabaseWithBody(ctx context.Context, id Id, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*http.Response, error) {
	req, err := newQueryDatabaseRequestWithBody(c.BaseURL, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	return c.Client.Do(req)
}

func (c *Client) QueryDatabase(ctx context.Context, id Id, body QueryDatabaseJSONRequestBody, reqEditors ...client.RequestEditorFn) (*QueryDatabaseResponse, error) {
	rsp, err := c.doQueryDatabase(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}

	return parseQueryDatabaseResponse(rsp)
}

// newQueryDatabaseRequest calls the generic QueryDatabase builder with application/json body.
func newQueryDatabaseRequest(baseURL *url.URL, id Id, body QueryDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return newQueryDatabaseRequestWithBody(baseURL, id, client.MIMEApplicationJSON, bodyReader)
}

func (c *Client) doQueryDatabase(ctx context.Context, id Id, body QueryDatabaseJSONRequestBody, reqEditors ...client.RequestEditorFn) (*http.Response, error) {
	req, err := newQueryDatabaseRequest(c.BaseURL, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	return c.Client.Do(req)
}

// parseQueryDatabaseResponse parses an HTTP response from a QueryDatabase call.
func parseQueryDatabaseResponse(rsp *http.Response) (*QueryDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &QueryDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagesList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// CreatePage: POST /v1/pages/

type CreatePageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Page
	JSON400      *Error
	JSON404      *Error
	JSON429      *Error
}

// Status returns HTTPResponse.Status
func (r CreatePageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreatePageRequestWithBody generates requests for CreatePage with any type of body
func newCreatePageRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreatePage)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreatePageWithBody returns a parsed response.
// POST /v1/pages/
func (c *Client) CreatePageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreatePageResponse, error) {
	rsp, err := c.doCreatePageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}

	return parseCreatePageResponse(rsp)
}

func (c *Client) doCreatePageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*http.Response, error) {
	req, err := newCreatePageRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	return c.Client.Do(req)
}

func (c *Client) CreatePage(ctx context.Context, body CreatePageJSONRequestBody, reqEditors ...client.RequestEditorFn) (*CreatePageResponse, error) {
	rsp, err := c.doCreatePage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}

	return parseCreatePageResponse(rsp)
}

// newCreatePageRequest calls the generic CreatePage builder with application/json body.
func newCreatePageRequest(baseURL *url.URL, body CreatePageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return newCreatePageRequestWithBody(baseURL, client.MIMEApplicationJSON, bodyReader)
}

func (c *Client) doCreatePage(ctx context.Context, body CreatePageJSONRequestBody, reqEditors ...client.RequestEditorFn) (*http.Response, error) {
	req, err := newCreatePageRequest(c.BaseURL, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	return c.Client.Do(req)
}

// parseCreatePageResponse parses an HTTP response from a CreatePage call.
func parseCreatePageResponse(rsp *http.Response) (*CreatePageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreatePageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Page
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// DeletePage: DELETE /v1/pages/{id}

type DeletePageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Page
	JSON400      *Error
	JSON404      *Error
	JSON429      *Error
}

// Status returns HTTPResponse.Status
func (r DeletePageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeletePageRequest generates requests for DeletePage
func newDeletePageRequest(baseURL *url.URL, id Id) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("id", id)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeletePageFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeletePage returns a parsed response.
// DELETE /v1/pages/{id}
func (c *Client) DeletePage(ctx context.Context, id Id, reqEditors ...client.RequestEditorFn) (*DeletePageResponse, error) {
	req, err := newDeletePageRequest(c.BaseURL, id)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeletePageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Page
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// GetPage: GET /v1/pages/{id}

type GetPageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Page
	JSON400      *Error
	JSON404      *Error
	JSON429      *Error
}

// Status returns HTTPResponse.Status
func (r GetPageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newGetPageRequest generates requests for GetPage
func newGetPageRequest(baseURL *url.URL, id Id) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("id", id)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathGetPageFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// GetPage returns a parsed response.
// GET /v1/pages/{id}
func (c *Client) GetPage(ctx context.Context, id Id, reqEditors ...client.RequestEditorFn) (*GetPageResponse, error) {
	req, err := newGetPageRequest(c.BaseURL, id)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &GetPageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Page
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// UpdatePage: PATCH /v1/pages/{id}

type UpdatePageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Page
	JSON400      *Error
	JSON404      *Error
	JSON429      *Error
}

// Status returns HTTPResponse.Status
func (r UpdatePageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdatePageRequestWithBody generates requests for UpdatePage with any type of body
func newUpdatePageRequestWithBody(baseURL *url.URL, id Id, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("id", id)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdatePageFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPatch, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdatePageWithBody returns a parsed response.
// PATCH /v1/pages/{id}
func (c *Client) UpdatePageWithBody(ctx context.Context, id Id, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdatePageResponse, error) {
	rsp, err := c.doUpdatePageWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}

	return parseUpdatePageResponse(rsp)
}

func (c *Client) doUpdatePageWithBody(ctx context.Context, id Id, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*http.Response, error) {
	req, err := newUpdatePageRequestWithBody(c.BaseURL, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	return c.Client.Do(req)
}

func (c *Client) UpdatePage(ctx context.Context, id Id, body UpdatePageJSONRequestBody, reqEditors ...client.RequestEditorFn) (*UpdatePageResponse, error) {
	rsp, err := c.doUpdatePage(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}

	return parseUpdatePageResponse(rsp)
}

// newUpdatePageRequest calls the generic UpdatePage builder with application/json body.
func newUpdatePageRequest(baseURL *url.URL, id Id, body UpdatePageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return newUpdatePageRequestWithBody(baseURL, id, client.MIMEApplicationJSON, bodyReader)
}

func (c *Client) doUpdatePage(ctx context.Context, id Id, body UpdatePageJSONRequestBody, reqEditors ...client.RequestEditorFn) (*http.Response, error) {
	req, err := newUpdatePageRequest(c.BaseURL, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	return c.Client.Do(req)
}

// parseUpdatePageResponse parses an HTTP response from a UpdatePage call.
func parseUpdatePageResponse(rsp *http.Response) (*UpdatePageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdatePageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Page
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// Search: POST /v1/search

type SearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagesList
	JSON400      *Error
	JSON404      *Error
	JSON429      *Error
}

// Status returns HTTPResponse.Status
func (r SearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newSearchRequestWithBody generates requests for Search with any type of body
func newSearchRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathSearch)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// SearchWithBody returns a parsed response.
// POST /v1/search
func (c *Client) SearchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*SearchResponse, error) {
	rsp, err := c.doSearchWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}

	return parseSearchResponse(rsp)
}

func (c *Client) doSearchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*http.Response, error) {
	req, err := newSearchRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	return c.Client.Do(req)
}

func (c *Client) Search(ctx context.Context, body SearchJSONRequestBody, reqEditors ...client.RequestEditorFn) (*SearchResponse, error) {
	rsp, err := c.doSearch(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}

	return parseSearchResponse(rsp)
}

// newSearchRequest calls the generic Search builder with application/json body.
func newSearchRequest(baseURL *url.URL, body SearchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return newSearchRequestWithBody(baseURL, client.MIMEApplicationJSON, bodyReader)
}

func (c *Client) doSearch(ctx context.Context, body SearchJSONRequestBody, reqEditors ...client.RequestEditorFn) (*http.Response, error) {
	req, err := newSearchRequest(c.BaseURL, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	return c.Client.Do(req)
}

// parseSearchResponse parses an HTTP response from a Search call.
func parseSearchResponse(rsp *http.Response) (*SearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &SearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagesList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ListUsers: GET /v1/users

type ListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsersList
	JSON400      *Error
	JSON404      *Error
	JSON429      *Error
}

// Status returns HTTPResponse.Status
func (r ListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListUsersRequest generates requests for ListUsers
func newListUsersRequest(baseURL *url.URL, params *ListUsersParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListUsers)

	q := queryURL.Query()

	if err := client.AddQueryParam(q, "page_size", params.PageSize); err != nil {
		return nil, err
	}

	if params.StartCursor != nil {
		if err := client.AddQueryParam(q, "start_cursor", *params.StartCursor); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListUsers returns a parsed response.
// GET /v1/users
func (c *Client) ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...client.RequestEditorFn) (*ListUsersResponse, error) {
	req, err := newListUsersRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsersList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// GetMe: GET /v1/users/me

type GetMeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *Error
	JSON404      *Error
	JSON429      *Error
}

// Status returns HTTPResponse.Status
func (r GetMeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newGetMeRequest generates requests for GetMe
func newGetMeRequest(baseURL *url.URL) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathGetMe)

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// GetMe returns a parsed response.
// GET /v1/users/me
func (c *Client) GetMe(ctx context.Context, reqEditors ...client.RequestEditorFn) (*GetMeResponse, error) {
	req, err := newGetMeRequest(c.BaseURL)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &GetMeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// GetUser: GET /v1/users/{id}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *Error
	JSON404      *Error
	JSON429      *Error
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newGetUserRequest generates requests for GetUser
func newGetUserRequest(baseURL *url.URL, id Id) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("id", id)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathGetUserFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// GetUser returns a parsed response.
// GET /v1/users/{id}
func (c *Client) GetUser(ctx context.Context, id Id, reqEditors ...client.RequestEditorFn) (*GetUserResponse, error) {
	req, err := newGetUserRequest(c.BaseURL, id)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}
